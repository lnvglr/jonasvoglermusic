
@import "./_foundation-boilerplate.scss";

$dynamic-relation: (
  small: large,
  medium: xlarge,
  large: xxlarge,
);


@function multiply-list($list, $multiplier) {
  $new-list: ();
  @each $item in $list {
    $new-list: join($new-list, ($item * $multiplier));
  }
  @return $new-list;
}
/// Computes an dynamic padding box.
///
/// @param {string} $edge
///   Padding or Margin.
/// @param {boolean} $negative
///   If negative or not.
/// @return {string} $axis
///   both, vertical or horizontal.

@mixin dynamic-box( $edge: padding, $negative: false, $axis: both ) {
  $multiplier: if($negative, -1, 1);
  @each $breakpoint, $edge-size in $dynamic-relation {
    @include breakpoint($breakpoint) {
      @if $axis == both {
        #{$edge}: multiply-list(map-get($padding-sizes, $edge-size), $multiplier);
      }
      @else if $axis == vertical {
        #{$edge}-top: multiply-list(extract-from-compact(map-get($padding-sizes, $edge-size), top), $multiplier);
        #{$edge}-bottom: multiply-list(extract-from-compact(map-get($padding-sizes, $edge-size), bottom), $multiplier);
      }
      @else if $axis == horizontal {
        #{$edge}-left: multiply-list(extract-from-compact(map-get($padding-sizes, $edge-size), left), $multiplier);
        #{$edge}-right: multiply-list(extract-from-compact(map-get($padding-sizes, $edge-size), right), $multiplier);
        @if $negative {
          max-width: calc(100% + (#{extract-from-compact(map-get($padding-sizes, $edge-size), left)} * 2));
          width: calc(100% + (#{extract-from-compact(map-get($padding-sizes, $edge-size), left)} * 2));
        }
      }
    }
  }
}
